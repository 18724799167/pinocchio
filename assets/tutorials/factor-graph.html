---
layout: default
title: footstep
---

<p>
{% highlight python %}
from pinocchio.utils import *
import numpy.linalg as npl

class Factor:
    def __init__(self, index, matrix):
        self.index = index
        self.matrix = matrix

class FactorGraph:
    def __init__(self,variableSize,nbVariables):
        '''
        Initialize a QP sparse problem as min || A x - b || so that C x = d
        where  x = (x1,..,xn), and dim(xi) = variableSize and n = nbVariables
        '''
        self.nx = variableSize
        self.N = nbVariables
        self.A = zero([0,self.N*self.nx])
        self.b = zero(0)
        self.C = zero([0,self.N*self.nx])
        self.d = zero(0)

    def matrixFromFactor(self,factors):
        '''
        Create a factor matrix [ A 0 A 0 A ... ] where the A's are placed at
        the indexes of the factors.
        '''
        assert( len(factors)>0 )
        nr = factors[0].matrix.shape[0] # nb rows of the factor
        nc = self.nx * self.N           # nb cols

        # Define and fill the new rows to be added
        A = zero([nr,nc])               # new factor to be added to self.A
        for factor in factors:
            assert( factor.matrix.shape == (nr,self.nx) )
            A[:,self.nx*factor.index:self.nx*(factor.index+1)] = factor.matrix
        return A

    def addFactor(self,factors,reference):
        '''
        Add a factor || sum_{i} factor[i].matrix * x_{factor[i].index} - reference ||
        '''

        # Add the new rows to the cost matrix.
        self.A = np.vstack([ self.A, self.matrixFromFactor(factors) ])
        self.b = np.vstack([ self.b, reference ])

    def addFactorConstraint(self,factors,reference):
        '''
        Add a factor sum_{i} factor[i].matrix * x_{factor[i].index} =  reference
        '''

        # Add the new rows to the cost matrix.
        self.C = np.vstack([ self.C, self.matrixFromFactor(factors) ])
        self.d = np.vstack([ self.d, reference ])

    def solve(self,eps = 1e-8):
        '''
        Implement a LCQP solver, with numerical threshold eps
        '''
        Cp = npl.pinv(self.C,eps)
        xopt = Cp*self.d
        P = eye(self.nx*self.N) - Cp*self.C
        xopt += npl.pinv(self.A*P,eps)*(self.b - self.A*xopt)
        return xopt
{% endhighlight %}
</p>